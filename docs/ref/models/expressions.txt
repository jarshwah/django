=====================
Query Expressions
=====================

.. module:: django.db.models
   :synopsis: Query Expressions

Query expressions describe a value or a computation that can be used
as part of a filter, an annotation, or an aggregation. There are a
number of built-in expressions that can be used to help you write
queries which are documented below. Expressions can be combined, or
in some cases nested, to form more complex computations.

Supported operations
~~~~~~~~~~~~~~~~~~~~

As well as addition, Django supports subtraction, multiplication, division,
and modulo arithmetic with Query Expressions, using Python constants,
variables, and even other expressions.

.. versionadded:: 1.7

    The power operator ``**`` is also supported.


Some examples
~~~~~~~~~~~~~

.. code-block:: python

    # Find companies that have more employees than chairs
    Company.objects.filter(num_employees__gt=F('num_chairs'))

    # Find companies that have at least twice as many employees
    # than chairs. Both the querysets below are equivalent
    Company.objects.filter(num_employees__gt=F('num_chairs') * 2)
    Company.objects.filter(
        num_employees__gt=F('num_chairs') + F('num_chairs'))

    # How many chairs are needed for each company to seat all employees?
    >>> company = Company.objects.filter(
    ...    num_employees__gt=F('num_chairs')).annotate(
    ...    chairs_needed=F('num_employees') - F('num_chairs')).first()
    >>> company.num_employees
    120
    >>> company.num_chairs
    50
    >>> company.chairs_needed
    70

    # Annotate models with an aggregated value. Both forms
    # below are equivalent
    Company.objects.annotate(num_products=Count('products'))
    Company.objects.annotate(num_products=Count(F('products')))

    # Aggregates can contain complex computations also
    Company.objects.annotate(num_offerings=Count(F('products') + F('services')))


Built-in Expressions
~~~~~~~~~~~~~~~~~~~~

``F()`` expressions
===================

.. class:: F

An ``F()`` object represents the value of a model field. It makes it possible
to refer to model field values and perform database operations using them
without actually having to pull them out of the database into Python memory.

Instead, Django uses the ``F()`` object to generate a SQL expression that
describes the required operation at the database level.

This is easiest to understand through an example. Normally, one might do
something like this::

    # Tintin filed a news story!
    reporter = Reporters.objects.get(name='Tintin')
    reporter.stories_filed += 1
    reporter.save()

Here, we have pulled the value of ``reporter.stories_filed`` from the database
into memory and manipulated it using familiar Python operators, and then saved
the object back to the database. But instead we could also have done::

    from django.db.models import F
    reporter = Reporters.objects.get(name='Tintin')
    reporter.stories_filed = F('stories_filed') + 1
    reporter.save()

Although ``reporter.stories_filed = F('stories_filed') + 1`` looks like a
normal Python assignment of value to an instance attribute, in fact it's an SQL
construct describing an operation on the database.

When Django encounters an instance of ``F()``, it overrides the standard Python
operators to create an encapsulated SQL expression; in this case, one which
instructs the database to increment the database field represented by
``reporter.stories_filed``.

Whatever value is or was on ``reporter.stories_filed``, Python never gets to
know about it - it is dealt with entirely by the database. All Python does,
through Django's ``F()`` class, is create the SQL syntax to refer to the field
and describe the operation.

.. note::

   In order to access the new value that has been saved in this way, the object
   will need to be reloaded::

       reporter = Reporters.objects.get(pk=reporter.pk)

As well as being used in operations on single instances as above, ``F()`` can
be used on ``QuerySets`` of object instances, with ``update()``. This reduces
the two queries we were using above - the ``get()`` and the
:meth:`~Model.save()` - to just one::

    reporter = Reporters.objects.filter(name='Tintin')
    reporter.update(stories_filed=F('stories_filed') + 1)

We can also use :meth:`~django.db.models.query.QuerySet.update()` to increment
the field value on multiple objects - which could be very much faster than
pulling them all into Python from the database, looping over them, incrementing
the field value of each one, and saving each one back to the database::

    Reporter.objects.all().update(stories_filed=F('stories_filed) + 1)

``F()`` therefore can offer performance advantages by:

* getting the database, rather than Python, to do work
* reducing the number of queries some operations require

.. _avoiding-race-conditions-using-f:

Avoiding race conditions using ``F()``
--------------------------------------

Another useful benefit of ``F()`` is that having the database - rather than
Python - update a field's value avoids a *race condition*.

If two Python threads execute the code in the first example above, one thread
could retrieve, increment, and save a field's value after the other has
retrieved it from the database. The value that the second thread saves will be
based on the original value; the work of the first thread will simply be lost.

If the database is responsible for updating the field, the process is more
robust: it will only ever update the field based on the value of the field in
the database when the :meth:`~Model.save()` or ``update()`` is executed, rather
than based on its value when the instance was retrieved.

Using ``F()`` in filters
------------------------

``F()`` is also very useful in ``QuerySet`` filters, where they make it
possible to filter a set of objects against criteria based on their field
values, rather than on Python values.

This is documented in :ref:`using F() expressions in queries
<using-f-expressions-in-filters>`


``Value()`` expressions
=======================

.. class:: Value(value, output_type=None)

The ``value`` argument describes the value to be included in the expression,
such as ``1``, ``True``, or ``None``. Django knows how to convert these python
values into their corresponding database type.

The ``output_type`` argument requires a model field type for django to load the
database value into, like ``IntegerField()`` or ``BooleanField()``.

A ``Value()`` object represents the smallest possible component of an expression;
a simple value. When you need to represent the value of an integer, boolean, or
string within an expression, you can wrap that value within a ``Value()``.

When you write the expression ``F('field') + 1``, Django will implicitly wrap
the ``1`` in a ``Value()``, allowing simple values to be used in more complex
expressions.


``Aggregate()`` expressions
===========================

.. class:: Aggregate(expression, output_type=None, **extra)

  .. attribute:: sql_template

    A class-level attribute, as a format string, that describes the SQL that
    is generated for this aggregate. Example::

        sql_template = '%(function)s( %(field)s )'

  .. attribute:: sql_function

    A class-level attribute describing the aggregate function that will be
    generated. Specifically, the sql_function will be interpolated as the
    ``function`` placeholder within ``sql_template``.

The ``expression`` argument can be the name of a field on the model, or another
expression.

The ``output_type`` argument requires a model field type for django to load the
database value into, like ``IntegerField()`` or ``FloatField()``.

.. note::
    ``output_type`` is only required when Django is unable to determine what
    field type the result should be. Complex expressions that mix field types
    should define the ``output_type`` wanted. Adding an ``IntegerField()``
    and a ``FloatField()`` together should probably have
    ``output_type=FloatField()`` defined for example.

The ``**extra`` kwargs are ``key=value`` pairs that can be interpolated
into the `sql_template` attribute.

An aggregate expression wraps the output of another expression with a SQL
function. It also informs the query that a ``GROUP BY`` expression is
required. All of the :ref:`Aggregate Functions <aggregation-functions>`,
like ``Sum()`` and ``Count()``, inherit from this.

Since ``Aggregates`` are expressions and wrap expressions, you can represent
some complex computations::

    Company.objects.annotate(
        all_employees=Count(F('num_employees') * 2) + Count('num_managers'))

.. versionadded:: 1.8

    Aggregate functions can now use arithmetic and reference multiple
    model fields in a single function.

Creating your own Aggregate Functions
-------------------------------------

Creating your own aggregate is extremely easy. At a minimum, you need
to define ``sql_function``, but you can also completely customize the
SQL that is generated. See a brief example below::

    class LowercaseSum(Aggregate):
        sql_function = 'sum'
        sql_template = '%(function)s( %(field)s ) /* %(comment)s */'

        def __init__(self, expression, output_type=None, comment=None, **extra):
            if comment is None:
                comment = 'Customise aggregate example'
            extra.update(comment=comment)
            super(LowercaseSum, self).__init__(expression, output_type=output_type, **extra)


Technical Information
~~~~~~~~~~~~~~~~~~~~~

Below you'll find technical implementation details that may be useful to
library authors. The technical API and examples below will help with
creating generic Query Expressions that can extend Django.

Expression API
==============

Query Expressions implement the :ref:`query expression API <query-expression>`,
but also expose a number of extra methods and attributes listed below. All
query expressions must derive from ``ExpressionNode()`` or a relevant
sub-class.

When a Query Expression wraps another expression, it is responsible for
delegating the methods.

.. attribute:: is_aggregate

    A class-level attribute that lets Django know that this expression
    is an aggregate, and a ``GROUP BY`` clause needs to be added to the
    query.

.. attribute:: is_ordinal

    A class-level attribute that is short-hand for specifying the
    ``output_type`` as an ``IntegerField()`` for aggregates.

.. attribute:: is_computed

    A class-level attribute that is short-hand for specifying the
    ``output_type`` as a ``FloatField()`` for aggregates.

.. attribute:: col

    If the expression resolves to one of the ``Column`` types, it
    should be set to the ``col`` attribute.

.. attribute:: source

    Holds a reference to the field type this expression is referencing,
    or is overridden by the ``output_type`` parameter to ``__init__()``.

    .. note::

       It is sometimes necessary to differentiate between the ``source``
       of an expression and the ``output_type``. For example, the source
       of ``Count('date_published')`` is a ``DateField()``, but the
       ``output_type`` will be an ``IntegerField()``. In most cases though,
       the ``output_type`` will simply return the ``source``.


.. method:: prepare(query=None, allow_joins=True, reuse=None)

    Provides the chance to do any preprocessing or validation of
    the expression before being added to the query. ``prepare()``
    should also be called on any nested expressions.

    ``query`` is the backend query implementation.

    ``allow_joins`` is a boolean that allows or denies the use of
    joins in the query.

    ``reuse`` is a set of reusable joins for multijoin scenarios.

.. method:: relabeled_clone(change_map)

    Returns a clone (copy) of self, with any column aliases relabeled.
    Column aliases are renamed when sub-queries are created.
    ``relabeled_clone()`` should also be called on any nested expressions
    and assigned to the clone.

    ``change_map`` is a dictionary mapping old aliases to new aliases.

    Example::

      def relabeled_clone(self, change_map):
          clone = copy.copy(self)
          clone.expression = clone.expression.relabeled_clone(change_map)
          return clone

.. method:: contains_aggregate(existing_aggregates)

    Returns the ``aggregate, lookup_path`` of the first aggregate
    that this expression, or any nested expression, references, or
    ``False, ()`` if no aggregate is referenced. For example::

        queryset.filter(num_chairs__gt=F('sum__employees'))

    The ``F()`` expression here references a previous ``Sum()``
    computation which means that this filter expression should be
    added to the ``HAVING`` clause rather than the ``WHERE`` clause.

    In the majority of cases, returning the result of ``contains_aggregate``
    on any nested expression should be appropriate, as the necessary built-in
    expressions will return the correct values.

.. method:: refs_field(aggregate_types, field_types)

    Allows backends (specifically SQLite) to ask the expression if
    there is an aggregate matching ``aggregate_types`` that has a
    ``source`` matching ``field_types``. SQLite does not allow
    most aggregations on date type fields, and will error if
    ``refs_field`` returns ``True``. ``refs_field`` should also
    be called on any nested expressions.

    ``aggregate_types`` is a tuple of aggregate classes, while
    ``field_types`` is a tuple of model fields.

.. method:: get_cols()

    Responsible for returning the list of columns references by
    this expression. ``get_cols()`` should be called on any nested
    expressions. ``F()`` objects, in particular, hold a reference to
    a column.

.. method:: get_group_by_cols()

    Responsible for returning the list of columns references by
    this expression. ``get_group_by_cols()`` should be called on any
    nested expressions. ``F()`` objects, in particular, hold a reference
    to a column.


Writing your own Query Expressions
==================================

You are able to write your own Query Expression classes that use, and
can integrate with, other Query Expressions. Let's step through an example
by writing an implementation of the ``COALESCE`` SQL function. The
``COALESCE`` SQL function is defined as taking a list of columns or
values. It will return the first column or value that isn't ``NULL``.

We'll start by defining the template to be used for SQL generation, and
the class parameters required::

  import copy
  from django.db.models import ExpressionNode

  class Coalesce(ExpressionNode):
      sql_template = 'COALESCE( %(expressions)s )'

      def __init__(self, expressions, output_type, **extra):
        super(Coalesce, self).__init__(None, None, False)
        if len(expressions) < 2:
            raise TypeError('expressions must have at least 2 elements')
        for expression in expressions:
            if not isinstance(expression, ExpressionNode):
                raise TypeError('%r is not an Expression' % expression)
        self.expressions = expressions
        self.source = output_type
        self.extra = extra

We do some basic validation on the parameters, including requiring at least
2 columns or values, and ensuring they are Expressions. We are requiring
``output_type`` here so that Django knows what kind of model field to assign
the eventual result to.

Now we implement the preprocessing and validation. Since we do not have
any of our own validation at this point, we just delegate to the nested
expressions::

    def prepare(self, query=None, allow_joins=True, reuse=None):
        for expression in self.expressions:
            expression.prepare(query, allow_joins, reuse)
        return self

Next, we write the method responsible for generating the SQL::

    def as_sql(self, compiler, connection):
        sql_expressions, sql_params = [], []
        for expression in self.expressions:
            sql, params = compiler.compile(expression)
            sql_expressions.append(sql)
            sql_params.extend(params)
        self.extra['expressions'] = ','.join(sql_expressions)
        return self.sql_template % self.extra, sql_params

    def as_oracle(self, compiler, connection):
        """ Oracle specific implementation. Lets make the
            function lowercase
        """
        self.sql_template = 'coalesce( %(expressions)s )'
        return self.as_sql(compiler, connection)

We generate the SQL for each of the ``expressions`` by using the
``compiler.compile()`` method, and join the result together with commas.
Then the template is filled out with our data and the SQL and parameters
are returned.

We've also defined a custom implementation that is specific to the Oracle
backend. The ``as_oracle()`` function will be called instead of ``as_sql()``
if the Oracle backend is in use.

Finally, we implement the rest of the methods that allow our Query Expression
to play nice with other Query Expressions::

    def relabeled_clone(self, change_map):
        clone = copy.copy(self)
        relabeled_expressions = [expr.relabeled_clone(change_map)
                                 for expr in self.expressions]
        clone.expressions = relabeled_expressions
        return clone

    def contains_aggregate(self, existing_aggregates):
        for expr in self.expressions:
            agg, lookup = expr.contains_aggregate(existing_aggregates)
            if agg:
                return agg, lookup
        return False, ()

    def refs_field(self, aggregate_types, field_types):
        return any(expr.refs_field(aggregate_types, field_types)
                   for expr in self.expressions)

    def get_cols(self):
        cols = []
        for child in self.expressions:
            cols.extend(child.get_cols())
        return cols

    def get_group_by_cols(self):
        cols = []
        for child in self.expressions:
            cols.extend(child.get_group_by_cols())
        return cols

Let's see how it works::

    >>> qs = Company.objects.annotate(
        tagline=Coalesce([
            F('motto'),
            F('ticker_name'),
            F('description'),
            Value('No Tagline', output_type=CharField())
            ], output_type=CharField()))
    >>> for c in qs:
    ...     print c
    ...     print c.tagline
    ...     print ----
    ...
    Company(name=Google, motto=Do No Evil, ticker_name=GOOG, description=Internet Company)
    Do No Evil
    ----
    Company(name=Apple, motto=None, ticker_name=AAPL, description=Think Different)
    AAPL
    ----
    Company(name=Yahoo, motto=None, ticker_name=None, description=Internet Company)
    Internet Company
    ----
    Company(name=Django Software Foundation, motto=None, ticker_name=None, description=None)
    No Tagline
