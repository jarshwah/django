.. _expressions:

=====================
Query Expressions
=====================

.. module:: django.db.models
   :synopsis: Query Expressions

Query expressions describe a value or a computation that can be used
as part of a filter, an annotation, or an aggregation. There are a
number of built-in expressions that can be used to help you write
queries which are documented below. Expressions can be combined, or
in some cases nested, to form more complex computations.

Supported operations
~~~~~~~~~~~~~~~~~~~~

As well as addition, Django supports subtraction, multiplication, division,
and modulo arithmetic with Query Expressions, using Python constants,
variables, and even other expressions.

.. versionadded:: 1.7

    The power operator ``**`` is also supported.


Some examples
~~~~~~~~~~~~~

.. code-block:: python

    # Find companies that have more employees than chairs
    Company.objects.filter(num_employees__gt=F('num_chairs'))

    # Find companies that have at least twice as many employees
    # than chairs. Both the querysets below are equivalent
    Company.objects.filter(num_employees__gt=F('num_chairs') * 2)
    Company.objects.filter(
        num_employees__gt=F('num_chairs') + F('num_chairs'))

    # How many chairs are needed for each company to seat all employees?
    >>> company = Company.objects.filter(
    ...    num_employees__gt=F('num_chairs')).annotate(
    ...    chairs_needed=F('num_employees') - F('num_chairs')).first()
    >>> company.num_employees
    120
    >>> company.num_chairs
    50
    >>> company.chairs_needed
    70

    # Annotate models with an aggregated value. Both forms
    # below are equivalent
    Company.objects.annotate(num_products=Count('products'))
    Company.objects.annotate(num_products=Count(F('products')))

    # Aggregates can contain complex computations also
    Company.objects.annotate(num_offerings=Count(F('products') + F('services')))


Built-in Expressions
~~~~~~~~~~~~~~~~~~~~

``F()`` expressions
===================

.. class:: F

An ``F()`` object represents the value of a model field. It makes it possible
to refer to model field values and perform database operations using them
without actually having to pull them out of the database into Python memory.

Instead, Django uses the ``F()`` object to generate a SQL expression that
describes the required operation at the database level.

This is easiest to understand through an example. Normally, one might do
something like this::

    # Tintin filed a news story!
    reporter = Reporters.objects.get(name='Tintin')
    reporter.stories_filed += 1
    reporter.save()

Here, we have pulled the value of ``reporter.stories_filed`` from the database
into memory and manipulated it using familiar Python operators, and then saved
the object back to the database. But instead we could also have done::

    from django.db.models import F
    reporter = Reporters.objects.get(name='Tintin')
    reporter.stories_filed = F('stories_filed') + 1
    reporter.save()

Although ``reporter.stories_filed = F('stories_filed') + 1`` looks like a
normal Python assignment of value to an instance attribute, in fact it's an SQL
construct describing an operation on the database.

When Django encounters an instance of ``F()``, it overrides the standard Python
operators to create an encapsulated SQL expression; in this case, one which
instructs the database to increment the database field represented by
``reporter.stories_filed``.

Whatever value is or was on ``reporter.stories_filed``, Python never gets to
know about it - it is dealt with entirely by the database. All Python does,
through Django's ``F()`` class, is create the SQL syntax to refer to the field
and describe the operation.

.. note::

   In order to access the new value that has been saved in this way, the object
   will need to be reloaded::

       reporter = Reporters.objects.get(pk=reporter.pk)

As well as being used in operations on single instances as above, ``F()`` can
be used on ``QuerySets`` of object instances, with ``update()``. This reduces
the two queries we were using above - the ``get()`` and the
:meth:`~Model.save()` - to just one::

    reporter = Reporters.objects.filter(name='Tintin')
    reporter.update(stories_filed=F('stories_filed') + 1)

We can also use :meth:`~django.db.models.query.QuerySet.update()` to increment
the field value on multiple objects - which could be very much faster than
pulling them all into Python from the database, looping over them, incrementing
the field value of each one, and saving each one back to the database::

    Reporter.objects.all().update(stories_filed=F('stories_filed) + 1)

``F()`` therefore can offer performance advantages by:

* getting the database, rather than Python, to do work
* reducing the number of queries some operations require

.. _avoiding-race-conditions-using-f:

Avoiding race conditions using ``F()``
--------------------------------------

Another useful benefit of ``F()`` is that having the database - rather than
Python - update a field's value avoids a *race condition*.

If two Python threads execute the code in the first example above, one thread
could retrieve, increment, and save a field's value after the other has
retrieved it from the database. The value that the second thread saves will be
based on the original value; the work of the first thread will simply be lost.

If the database is responsible for updating the field, the process is more
robust: it will only ever update the field based on the value of the field in
the database when the :meth:`~Model.save()` or ``update()`` is executed, rather
than based on its value when the instance was retrieved.

Using ``F()`` in filters
------------------------

``F()`` is also very useful in ``QuerySet`` filters, where they make it
possible to filter a set of objects against criteria based on their field
values, rather than on Python values.

This is documented in :ref:`using F() expressions in queries
<using-f-expressions-in-filters>`


``Value()`` expressions
=======================

.. class:: Value(value, output_type=None)

The ``value`` argument describes the value to be included in the expression,
such as ``1``, ``True``, or ``None``. Django knows how to convert these python
values into their corresponding database type.

The ``output_type`` argument requires a model field type for django to load the
database value into, like ``IntegerField()`` or ``BooleanField()``.

A ``Value()`` object represents the smallest possible component of an expression;
a simple value. When you need to represent the value of an integer, boolean, or
string within an expression, you can wrap that value within a ``Value()``.

When you write the expression ``F('field') + 1``, Django will implicitly wrap
the ``1`` in a ``Value()``, allowing simple values to be used in more complex
expressions.

.. _func-expressions:

``Func()`` expressions
======================

.. class:: Func(*expressions, **extra)

  .. attribute:: function

    A class-level attribute describing the function that will be
    generated. Specifically, the ``function`` will be interpolated as the
    ``function`` placeholder within ``template``. Default::

      function = None

  .. attribute:: template

    A class-level attribute, as a format string, that describes the SQL that
    is generated for this function. Default::

      template = '%(function)s(%(expressions)s)'

  .. attribute:: arg_joiner

    A class-level attribute that denotes the character used to join the list
    of ``expressions`` together. Default::

      arg_joiner = ', '

The ``*expressions`` is a list of positional expressions that the function
will be applied to. The expressions will be converted to strings, joined
together with ``arg_joiner``, and then interpolated into the ``template``
as the ``expressions`` placeholder.

The ``**extra`` kwargs are ``key=value`` pairs that can be interpolated
into the ``template`` attribute. Note that the keywords ``function`` and
``template`` can be used to replace the ``function`` and ``template``
attributes respectively, without having to define your own class.
``output_type`` can be used to define the expected django return type.

.. versionadded:: 1.8

    User-defined functions can now be created and used.

Func expressions are the base type of all expressions that involve database
functions, like ``COALESCE``, ``LOWER``, or aggregates like ``SUM``. They
can be used directly::

    .annotate(field_lower=Func(F('field'), function='LOWER'))

or they can be used to build a library of database functions::

    class Lower(Func):
        function = 'LOWER'

    .annotate(field_lower=Lower(F('field')))

But both cases will result in a queryset where each model is annoated with an
extra attribute ``field_lower`` produced, roughly, from the following SQL::

    SELECT
        ...
        LOWER("app_label"."field") as "field_lower"

``Aggregate()`` expressions
===========================

.. class:: Aggregate(expression, output_type=None, **extra)

  .. attribute:: template

    A class-level attribute, as a format string, that describes the SQL that
    is generated for this aggregate. Default::

        template = '%(function)s( %(expressions)s )'

  .. attribute:: function

    A class-level attribute describing the aggregate function that will be
    generated. Specifically, the ``function`` will be interpolated as the
    ``function`` placeholder within ``template``. Default::

        function = None

The ``expression`` argument can be the name of a field on the model, or another
expression. It will be converted to a string and used as the ``expressions``
placeholder within the ``template``.

The ``output_type`` argument requires a model field type for django to load the
database value into, like ``IntegerField()`` or ``FloatField()``.

.. note::
    ``output_type`` is only required when Django is unable to determine what
    field type the result should be. Complex expressions that mix field types
    should define the ``output_type`` wanted. Adding an ``IntegerField()``
    and a ``FloatField()`` together should probably have
    ``output_type=FloatField()`` defined, for example.

The ``**extra`` kwargs are ``key=value`` pairs that can be interpolated
into the ``template`` attribute.

An aggregate expression is a special case of a :ref:`Func() expression
<func-expressions>`, that informs the query that a ``GROUP BY`` clause
is required. All of the :ref:`Aggregate Functions <aggregation-functions>`,
like ``Sum()`` and ``Count()``, inherit from ``Aggregate()``.

Since ``Aggregates`` are expressions and wrap expressions, you can represent
some complex computations::

    Company.objects.annotate(
        all_employees=Count(F('num_employees') * 2) + Count('num_managers'))

.. versionadded:: 1.8

    Aggregate functions can now use arithmetic and reference multiple
    model fields in a single function.

Creating your own Aggregate Functions
-------------------------------------

Creating your own aggregate is extremely easy. At a minimum, you need
to define ``function``, but you can also completely customize the
SQL that is generated. See a brief example below::

    class LowercaseSum(Aggregate):
        function = 'sum'
        template = '%(function)s( %(expressions)s ) /* %(comment)s */'

        def __init__(self, expression, output_type=None, comment=None, **extra):
            if comment is None:
                comment = 'Customise aggregate example'
            extra.update(comment=comment)
            super(LowercaseSum, self).__init__(expression, output_type=output_type, **extra)


Technical Information
~~~~~~~~~~~~~~~~~~~~~

Below you'll find technical implementation details that may be useful to
library authors. The technical API and examples below will help with
creating generic Query Expressions that can extend Django.

Expression API
==============

Query Expressions implement the :ref:`query expression API <query-expression>`,
but also expose a number of extra methods and attributes listed below. All
query expressions must derive from ``ExpressionNode()`` or a relevant
sub-class.

When a Query Expression wraps another expression, it is responsible for
delegating the methods.

.. class:: ExpressionNode

    .. attribute:: is_aggregate

        A class-level attribute that lets Django know that this expression
        is an aggregate and a ``GROUP BY`` clause needs to be added to the
        query.

    .. attribute:: is_ordinal

        A class-level attribute that is short-hand for specifying the
        ``output_type`` as an ``IntegerField()`` for aggregates. Will
        ensure that any ``NULLS`` are converted to ``0``.

    .. attribute:: is_computed

        A class-level attribute that is short-hand for specifying the
        ``output_type`` as a ``FloatField()`` for aggregates.

    .. attribute:: col

        If the expression resolves to one of the ``Column`` types, it
        should be set as the ``col`` attribute.

    .. attribute:: source

        Holds a reference to the field type this expression is referencing,
        or is overridden by the ``output_type`` kwarg to ``__init__()``.

        .. note::

           It is sometimes necessary to differentiate between the ``source``
           of an expression and the ``output_type``. For example, the source
           of ``Count('date_published')`` is a ``DateField()``, but the
           ``output_type`` will be an ``IntegerField()``. In most cases though,
           the ``output_type`` will simply return the ``source``.

    .. attribute:: output_type

        The ``output_type`` attribute is used by the ``get_lookup()``
        method to check for lookups. The output_type should be a field,
        and commonly returns the ``source``.

    .. method:: as_sql(compiler, connection)

        Responsible for producing the query string and parameters for the
        expression. The ``compiler`` is a ``SQLCompiler`` object, which has a
        ``compile()`` method that can be used to compile other expressions. The
        ``connection`` is the connection used to execute the query.

        Calling expression.as_sql() directly is usually incorrect -
        instead ``compiler.compile(expression)`` should be used. The
        ``compiler.compile()`` method will take care of calling vendor-specific
        methods of the expression.

    .. method:: as_vendorname(compiler, connection)

        Works like ``as_sql()`` method. When an expression is compiled by
        ``compiler.compile()``, Django will first try to call ``as_vendorname()``, where
        vendorname is the vendor name of the backend used for executing the query.
        The vendorname is one of ``postgresql``, ``oracle``, ``sqlite`` or
        ``mysql`` for Django's built-in backends.

    .. method:: get_lookup(lookup_name)

        The ``get_lookup()`` method is used to fetch lookups. By default the
        lookup is fetched from the expression's output type in the same way
        described in registering and fetching lookup documentation below.
        It is possible to override this method to alter that behavior.

    .. method:: get_transform(lookup_name)

        The ``get_transform()`` method is used when a transform is needed rather
        than a lookup, or if a lookup is not found. This is a more complex
        situation which is useful when there arbitrary possible lookups for a
        field. Generally speaking, you will not need to override ``get_lookup()``
        or ``get_transform()``, and can use ``register_lookup()`` instead.

    .. method:: prepare(query=None, allow_joins=True, reuse=None, summarise=False)

        Provides the chance to do any preprocessing or validation of
        the expression before being added to the query. ``prepare()``
        should also be called on any nested expressions.

        ``query`` is the backend query implementation.

        ``allow_joins`` is a boolean that allows or denies the use of
        joins in the query.

        ``reuse`` is a set of reusable joins for multijoin scenarios.

        ``summarise`` is a boolean that, when ``True``, signals that the
        query being computed is a terminal aggregate query.

    .. method:: relabeled_clone(change_map)

        Returns a clone (copy) of self, with any column aliases relabeled.
        Column aliases are renamed when sub-queries are created.
        ``relabeled_clone()`` should also be called on any nested expressions
        and assigned to the clone.

        ``change_map`` is a dictionary mapping old aliases to new aliases.

        Example::

          def relabeled_clone(self, change_map):
              clone = copy.copy(self)
              clone.expression = self.expression.relabeled_clone(change_map)
              return clone

    .. method:: contains_aggregate(existing_aggregates)

        Returns the ``(aggregate, lookup_path)`` of the first aggregate
        that this expression, or any nested expression, references, or
        ``False, ()`` if no aggregate is referenced. For example::

            queryset.filter(num_chairs__gt=F('sum__employees'))

        The ``F()`` expression here references a previous ``Sum()``
        computation which means that this filter expression should be
        added to the ``HAVING`` clause rather than the ``WHERE`` clause.

        In the majority of cases, returning the result of ``contains_aggregate``
        on any nested expression should be appropriate, as the necessary built-in
        expressions will return the correct values.

    .. method:: refs_field(aggregate_types, field_types)

        Allows backends (specifically SQLite) to ask the expression if
        there is an aggregate matching ``aggregate_types`` that has a
        ``source`` matching ``field_types``. SQLite does not allow
        most aggregations on date type fields, and will error if
        ``refs_field`` returns ``True``. ``refs_field`` should also
        be called on any nested expressions.

        ``aggregate_types`` is a tuple of aggregate classes, while
        ``field_types`` is a tuple of model fields.

    .. method:: get_group_by_cols()

        Responsible for returning the list of columns references by
        this expression. ``get_group_by_cols()`` should be called on any
        nested expressions. ``F()`` objects, in particular, hold a reference
        to a column.

Writing your own Query Expressions
==================================

You are able to write your own Query Expression classes that use, and
can integrate with, other Query Expressions. Let's step through an example
by writing an implementation of the ``COALESCE`` SQL function, without
using the built-in :ref:`Func() expressions <func-expressions>`.

The ``COALESCE`` SQL function is defined as taking a list of columns or
values. It will return the first column or value that isn't ``NULL``.

We'll start by defining the template to be used for SQL generation, and
the class parameters required::

  import copy
  from django.db.models import ExpressionNode

  class Coalesce(ExpressionNode):
      template = 'COALESCE( %(expressions)s )'

      def __init__(self, expressions, output_type, **extra):
        super(Coalesce, self).__init__(output_type=output_type)
        if len(expressions) < 2:
            raise TypeError('expressions must have at least 2 elements')
        for expression in expressions:
            if not isinstance(expression, ExpressionNode):
                raise TypeError('%r is not an Expression' % expression)
        self.expressions = expressions
        self.extra = extra

We do some basic validation on the parameters, including requiring at least
2 columns or values, and ensuring they are Expressions. We are requiring
``output_type`` here so that Django knows what kind of model field to assign
the eventual result to.

Now we implement the preprocessing and validation. Since we do not have
any of our own validation at this point, we just delegate to the nested
expressions::

    def prepare(self, query=None, allow_joins=True, reuse=None, summarise=False):
        for expression in self.expressions:
            expression.prepare(query, allow_joins, reuse, summarise)
        return self

Next, we write the method responsible for generating the SQL::

    def as_sql(self, compiler, connection):
        sql_expressions, sql_params = [], []
        for expression in self.expressions:
            sql, params = compiler.compile(expression)
            sql_expressions.append(sql)
            sql_params.extend(params)
        self.extra['expressions'] = ','.join(sql_expressions)
        return self.template % self.extra, sql_params

    def as_oracle(self, compiler, connection):
        """
        Oracle specific implementation. Lets make the
        function lowercase
        """
        self.template = 'coalesce( %(expressions)s )'
        return self.as_sql(compiler, connection)

We generate the SQL for each of the ``expressions`` by using the
``compiler.compile()`` method, and join the result together with commas.
Then the template is filled out with our data and the SQL and parameters
are returned.

We've also defined a custom implementation that is specific to the Oracle
backend. The ``as_oracle()`` function will be called instead of ``as_sql()``
if the Oracle backend is in use.

Finally, we implement the rest of the methods that allow our Query Expression
to play nice with other Query Expressions::

    def relabeled_clone(self, change_map):
        clone = copy.copy(self)
        relabeled_expressions = [
            expr.relabeled_clone(change_map)
            for expr in self.expressions]
        clone.expressions = relabeled_expressions
        return clone

    def contains_aggregate(self, existing_aggregates):
        for expr in self.expressions:
            agg, lookup = expr.contains_aggregate(existing_aggregates)
            if agg:
                return agg, lookup
        return False, ()

    def refs_field(self, aggregate_types, field_types):
        return any(expr.refs_field(aggregate_types, field_types)
                   for expr in self.expressions)

    def get_group_by_cols(self):
        cols = []
        for child in self.expressions:
            cols.extend(child.get_group_by_cols())
        return cols

Let's see how it works::

    >>> qs = Company.objects.annotate(
        tagline=Coalesce([
            F('motto'),
            F('ticker_name'),
            F('description'),
            Value('No Tagline')
            ], output_type=CharField()))
    >>> for c in qs:
    ...     print c
    ...     print c.tagline
    ...     print ----
    ...
    Company(name=Google, motto=Do No Evil, ticker_name=GOOG, description=Internet Company)
    Do No Evil
    ----
    Company(name=Apple, motto=None, ticker_name=AAPL, description=Think Different)
    AAPL
    ----
    Company(name=Yahoo, motto=None, ticker_name=None, description=Internet Company)
    Internet Company
    ----
    Company(name=Django Software Foundation, motto=None, ticker_name=None, description=None)
    No Tagline
